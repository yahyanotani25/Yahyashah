"""
modules/exploit_manager.py (enhanced)

– Validates exploit module before running
– Caches loaded exploits in memory for reuse
– Exception‐safe, logs all outcomes
"""

import os
import json
import logging
import importlib.util
from pathlib import Path
import time

from modules.config import load_config
from modules.logger import log_event

logger = logging.getLogger("exploit_manager")
REPO_ROOT = Path(__file__).parent.parent.resolve()
EXPLOIT_LIB_DIR = REPO_ROOT / "modules" / "exploit_lib"
_loaded_exploits = {}
CONFIG = load_config()

def _load_exploit_module(name: str):
    """
    Load an exploit module once and cache it.
    """
    if name in _loaded_exploits:
        return _loaded_exploits[name]
    module_path = EXPLOIT_LIB_DIR / f"{name}.py"
    if not module_path.exists():
        raise FileNotFoundError(f"Exploit {name} not found.")
    spec = importlib.util.spec_from_file_location(f"exploit_{name}", str(module_path))
    if spec is None or spec.loader is None:
        raise ImportError(f"Failed to create spec for exploit {name}")
    module_obj = importlib.util.module_from_spec(spec)
    try:
        spec.loader.exec_module(module_obj)
    except Exception as e:
        logger.exception(f"Failed to import exploit {name}: {e}")
        raise
    if not hasattr(module_obj, "exploit"):
        raise AttributeError(f"Exploit {name} does not define exploit()")
    _loaded_exploits[name] = module_obj
    return module_obj

def run_exploit(exploit_name: str, target: str, **kwargs):
    """
    Dynamically run exploit(exploit_name). Returns its dict or error dict.
    """
    try:
        module_obj = _load_exploit_module(exploit_name)
        logger.info(f"Running exploit {exploit_name} against {target} with args {kwargs}")
        try:
            result = module_obj.exploit(target, **kwargs)
        except TypeError:
            # If exploit signature is (target) only
            result = module_obj.exploit(target)
        except Exception as ex:
            logger.exception(f"Exploit {exploit_name} runtime error: {ex}")
            result = {"status":"error","detail":str(ex)}
        log_event("exploit_manager", f"{exploit_name} on {target}: {result}".encode())
        return result
    except Exception as e:
        logger.error(f"run_exploit error: {e}")
        return {"status":"error","detail":str(e)}

def fetch_latest_exploits():
    """
    Use automatic_cve_fetcher to download latest exploit scripts.
    """
    try:
        fetcher_path = EXPLOIT_LIB_DIR / "automatic_cve_fetcher.py"
        spec = importlib.util.spec_from_file_location("automatic_cve_fetcher", str(fetcher_path))
        if spec is None or spec.loader is None:
            raise ImportError("Failed to create spec for automatic_cve_fetcher")
        module_obj = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module_obj)
        return module_obj.fetch_exploits(CONFIG.get("exploit_repo_url"))
    except Exception as e:
        logger.error(f"fetch_latest_exploits error: {e}")
        return {"status":"error","detail":str(e)}

def exploit_manager_loop():
    """Background loop for exploit management"""
    while True:
        try:
            # Fetch latest exploits
            fetch_latest_exploits()
            time.sleep(14400)  # Check every 4 hours
        except Exception as e:
            log_event("exploit_manager", f"Exploit manager loop error: {e}".encode())
            time.sleep(3600)  # Wait 1 hour on error
